# Page Replacement Algorithm

페이징 기법으로 메모리를 관리하는 운영체제에서, 페이지 부재가 발생 하여 새로운 페이지를 할당하기 위해 현재 할당된 페이지 중 어느 것과 교체할지를 결정하는 방법이다.

## 종류
> 1 FIFO (First In First Out)       : 먼저 적재한 페이지부터 교체<br>
2 OPT (Optimal Replacement)       : 가장 오랫동안 사용하지 않을 것으로 예측한 페이지를 교체<br>
3 LRU (Least Recently Used)       : 최근에 사용하지 않은 페이지를 교체<br>
4 NUR (Not Used Recently)         : 최근에 사용하지 않은 페이지를 교체<br>
5 LFU (Least Frequently Used)     : 사용 횟수가 가장 적은 페이지를 교체<br>
6 MFU (Most Frequently Used)      : 사용 횟수가 가장 많은 페이지를 교체<br>
7 SCR (Second Chance Replacement) : FIFO 기법의 단점을 보완하는 기법으로 교체 대상을 판별하기 전에 참조 비트를 
검사하여 1일 때 한 번의 기회를 더 부여 참조 비트가 1이면 큐의 맨 뒤로 피드백
------

## 각 페이지 교체 알고리즘 설명

### 1 FIFO

FIFO는 먼저 쓰였던 페이지프레임을 먼저 page out 시키는 방법이다. 이 방법의 가장 큰 장점은 구혀하기가 간단하다는 것이었으나 Locality(지역성)의 개념이 등장한 이후 환영받지 못했다. 현재 쓰이고 있는 페이지프레임은 당분간 계속해 쓰인다는 Locality의 개념과는 FIFO가 반대되는 개념이었기 때문이다. 그러나 최근 멀티미디어는 또 다시 Locality의 개념을 제외시키고 있다. 동영상 지원이 가장 큰 관건인 멀티미디어는 영상이 지원되는 동안 한번 접근한 페이지프레임은 다시 접근하지 않기 때문이다. 계속해서 새로운 페이지 프레임을 접근하여 동영상을 완성해나가기 때문이다.

### 2 OPTIMAL

이 방법은 앞으로 안 쓰일 페이지프레임을 page out 시키는 것이다. 그러나 이 방법은 이론상으로 존재할 뿐 실제로 적용되기는 불가능하다. 어떤 페이지프레임이 앞으로 쓰이지 않을지는 아무도 모르기 때문이다.

### 3 LRU

LRU의 방법은 가장 오랫동안 사용되지 않았던 페이지 프레임을 page out 시키는 방법으로 Locality를 전제로 현재 안 쓰이는 페이지프레임은 계속 안 쓰일 것 이라는 생각을 바탕에 둔 것이다.
그렇다면 가장 최근에 안 쓰인 페이지프레임을 어떻게 확인할 것인가...
> 1 : 페이지프레임마다 시간을 기록하는 것 -> 초당 백 만 번 이상의 페이지프레임참조가 발생하는데 페이지프레임에 타입스태프를 찍어주는데 몇 천 분에 1초가 걸린다면 너무 비효율적이다. <br>
2 : 리스트를 만들어 sorting을 함으로 최근 쓰인 페이지 프레임과 쓰이지 않은 페이지 프레임을 구분해 내는 것. 이 방법이 쓰이지만 단점이 있다. 단점은 하나의 페이지 프레임이 빠진 앞 뒤의 페이지 프레임을 붙이는 데에 대한 포인터 변화를 저장하는 것, 바로 포인터 갱신을 위한 overhead가 단점이다.

### 4 NUR

LRU와 비슷한 페이지 교체 알고리즘이다. 참조비트와 수정비트를 사용하면 LRU에서 나타나는 오버헤드를 줄일 수 있다.

### 5 LFU

페이지들에 대해 이들이 참조된 횟수를 기준으로 교체될 페이지를 선정하는 기법이다. 페이지 교체가 일어나야할 상황에서 가장 참조 횟수가 적은 페이지를 교체한다. 만일 교체 대상인 페이지가 여러 개일 경우, LRU기법에 따라 페이지를 교체한다.
LRU기법이 갖는 오버헤드를 줄이면서 LRU기법에서처럼 지역성을 이용한다. 단점은 참조 될 가능성이 많음에도 불구하고 횟수에 의한 방법이므로 최근에 사용된 프로그램은 교체시킬 가능성이 있고, 해당 횟수를 증가시키므로 오버헤드가 발생한다.

### 6 MFU

LFU와는 반대되는 개념으로 참조 횟수가 가장 많은 페이지를 교체한다.

### 7 SCR

FIFO 기법의 단점을 보완하는 기법으로 교체 대상을 판별하기 전에 참조 비트를 검사하여 1일 때 한 번의 기회를 더 부여 참조 비트가 1이면 큐의 맨 뒤로 피드백

### 8 RAMDOM

지역성이 존재하지 않은 채, 전혀 예측할 수 없이 불규칙적으로 수행되는 프로그램의 경우 페이지프레임을 아무런 규칙없이 page out 시키는 것을 말한다.

## 하드웨어를 사용한 page out

소프트웨어를 사용했을 때 겪었던 많은 어려움을 하드웨어의 도움을 받음으로써 더 이상 시간과 메모리를 낭비하지 않을 방법이 고안되었다. 하드웨어를 사용해 page out 시킬 때는 앞서 배운 PTE에 참조비트와 수정비트를 셋팅해 비트값의 변화를 관찰해 page out이 실행되게 된다.

> 참조비트 0: 해당 페이지 프레임이 참조되지 않았다. <br>
참조비트 1: 해당 페이지 프레임이 참조되었다.

바로 PTE에 이러한 참조비트를 두고 MMU가 페이지프레임을 참조할 때마다 0인 참조비트를 1로 셋팅 시키는 것이다. 그리고 page out daemon은 PTE를 검사해 참조비트가 0인 페이지프레임을 pageout 시키게 된다. 그렇다면 수정비트가 의미하는 것은 무엇일까.

> 수정비트 0: 해당 페이지 프레임의 내용이 수정되지 않았다.
수정비트 1: 해당 페이지 프레임의 내용이 수정된 적이 있따.

참조비트가 0인 두 개의 페이지프레임이 존재할 때는 수정비트를 확인하여 수정비트가 0인 페이지프레임을 먼저 page out하게 되는 것이다. 그 이유는 수정된 페이지프레임을 대체 시키려면 수정된 내용을 다시 저장해야하는 번거로움이 있기 때문이다.

## Page window

page out daemon은 실제 메모리 안의 페이지프레임들을 전부 다 검사하지는 않는다. Page window의 범위 내에 존재하는 페이지 프레임을 검사한다.

## Thrashing

페이지 교환이 너무 자주 일어나는 상황을 Thrashing 이라고 한다. Thrashing이 발생하는 원인은 메모리 부족과 swap space의 부족을 들 수 있다. 이렇듯 페이지교체전략이 효율적이지 못할 때는 Working set을 수정하여 page in이 발생하는 페이지들을 메모리에 유지될 수 있도록 해야 한다. 만약 컴퓨터 시스템상의 어느 부문에선가 병목 현상이 발생했다면 Thrashing을 점검해볼 필요가 있다.

#### 참고 블로그
- https://vmilsh.tistory.com/387
- https://m.blog.naver.com/kyung778/60164009610
- https://chobodogfootruler.tistory.com/22